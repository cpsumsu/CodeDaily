---
title: "32. Longest Valid Parentheses"
tags: ["monotonic stack"]
---

> Problem: [32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/description/)

# Reasoning 
- The main idea is that:
1. when meet '(', push the index in stack
2. when meet ')', check whether the stack is empty.
3. if not empty, that means the stack has either '(' or ')' on the top

4. if '(' on the top, it can form a valid parenthese, so pop it
5. then check whether it is empty again, 
6. to find the distance of valid parentheses

7. if ')' on the top, it is invalid since ')' and ')' can't form valid parenthese
8. it maintain only 1 ')' in the stack (reader should verify this statement)
9. so if it is invalid situation, then pop the previous ')' out, the stack is now empty
10. push the new ')' into the stack to record the new invalid situation.

NOTE: push -1 to the stack at the begining to ensure later algorithm push the first invalid ')' into stack

# Complexity
## Time Complexity
> $O(N)$
## Space Complexity
> $O(N)$
where N be the length of string s

# Code
```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        st.push(-1);

        int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(')
                st.push(i);
            else {
                if (st.size()) {
                    st.pop();

                    if (st.size())
                        ans = max(ans, i - st.top());
                    else 
                        st.push(i);
                }
            }
        }

        return ans;
    }
};
```

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        st = deque()
        st.append(-1)
        ans = 0
        for i in range(len(s)):
            if (s[i] == '('):
                st.append(i)
            else:
                st.pop()
                if not st:
                    st.append(i)
                else:
                    ans = max(ans, i - st[-1])
        return ans
```