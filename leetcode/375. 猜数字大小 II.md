---
Difficulty: "Medium"
tags: ["dp"]
---

> Problem: [375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/description/)

# 思路

區間dp，dp[i][j] 代表在區間[i, j]內猜到目標數字的最少花費

# 解题方法

## (1)解释dp[1][1]:

dp[1][1]是指只有一个数字1，我们以1作为分割点(猜的数)，赢得游戏所用钱的最小值，一看就知道，dp[1][1]=0。因为我们只能猜1，答案也只能是1，不用花钱

## (2)解释dp[1][2]:

dp[1][2]是指只有两个数字1，2

我们先以1作为分割点(猜的数):

```c++
猜1：    
答案是1，花费0元
答案是2，花费1元
必定赢得游戏，最多花费1元
```

我们再以2作为分割点(猜的数):

```c++
猜2：
答案是1，花费2元
答案是2，花费0元
必定赢得游戏，最多花费2元
```

综上，只要进入[1,2]这个区间，我们第一次猜1，只要花费1元，必定可以赢得游戏（假如看不懂，再看一次，细细的品）

所以dp[1][2]=1(只要花1元必定赢得游戏，当第一次猜1时)

## (3)解释dp[2][3]:

dp[2][3]是指只有两个数字2，3

有一个小问题，为什么不是从1开始呢？(明白的不用看)

比如n=3，我们第一次猜了1，但是答案是2或者3，反正不是1，我们是不是要到[2,3]区间来寻找答案，即求

dp[2][3]

我们先以2作为分割点(猜的数):

```
猜2：    
答案是2，花费0元
答案是3，花费2元
必定赢得游戏，最多花费2元
我们再以3作为分割点(猜的数):
```

猜3：
```
答案是2，花费3元
答案是3，花费0元
必定赢得游戏，最多花费3元
```

综上，只要进入[2,3]这个区间，我们第一次猜2，只要花费2元，必定可以赢得游戏
所以dp[2][3]=2(只要花2元必定赢得游戏，当第一次猜2时)

## (4)解释dp[1][3]:

dp[1][3]是指只有三个数字1，2，3
我们先以1作为分割点(猜的数):

```
猜1：
答案是1，花费0元
答案是2或者3，这个时候会进入另一个区间[2,3]，花费1+dp[2][3]元
必定赢得游戏，最多花费max(0,1+dp[2][3])元
我们再以2作为分割点(猜的数):
```

```
猜2：
答案是1，花费2+dp[1][1]=2+0=2元
答案是2，花费0元
答案是3，花费2+dp[3][3]=2+0=2元
必定赢得游戏，最多花费max(0,2+dp[1][1],2+dp[3][3])元
我们最后以3作为分割点(猜的数):
```

```
猜3：
答案是1或者2,花费3+dp[1][2]元
答案是3，花费0元
必定赢得游戏，最多花费max(0,3+dp[1][2])元
综上，只要进入[1][3]这个区间，我们只要花费min( max(0,1+dp[2][3]) , max(0,2+dp[1][1],2+dp[3][3]) , max(0,3+dp[1][2]) )元必定可以赢的游戏
而dp[1][3]也就等于那个min的值。
```

可以发现，只要找到dp[1][n]即可。
(假如不能明白dp[i][j]可以返回上面内容看例子，明白后再往下阅读)

# 3.状态转移方程
状态转移方程怎么写呢？

看第4个例子，dp[1][3]我们就可以发现：

- 对于每一个分割点，我们取它左右两边区间的最大值加上分割点本身作为取此分割点的dp[i][j]值
- 对于每一个区间，我们取所有分割点的dp[i][j]的最小值作为dp[i][j]的真正的值
- 特别地，对于以i作为分割点的dp[i][j]，只取i右边的区间；对于以j作为分割点的dp[i][j]，只取j左边的区间

这个我觉得看懂dp[1][3]不难理解，要是理解不了的话，我这样解释一下(明白的不用看)：

```
i i+1 i+2 ... ... j-2 j-1 j

以i+1为分割点对应的：dp1=max(dp[i][i],dp[i+2][j])+i+1

以j-1为分割点对应的: dp2=max(dp[i][j-2],dp[j][j])+j-1

特别地,以i为分割点：dp0=i+dp[i+1][j];以j为分割点: dp3=j+dp[i][j-1]

dp[i][j]=min(dp0,dp1,dp2,dp3)
```

# 4.数组填充
给出一个dp二维数组来用代码填充它，“\”表示正无穷

```
(1)初始化：         (2)易知dp[i][i]=0   
| \ \ \ \ |         | 0 \ \ \ |
| \ \ \ \ |         | \ 0 \ \ |
| \ \ \ \ |         | \ \ 0 \ |
| \ \ \ \ |         | \ \ \ 0 |
```

接下来要考虑怎么填充矩阵以得到dp[1][n]:

很容易我们发现可以用一个位置左边和下边地数据来计算它本身，因此可以这样填充

(3)填充1列：
```c++
| 0 1 \ \ |  dp[1][2]计算步骤向上看
| \ 0 \ \ |
| \ \ 0 \ |
| \ \ \ 0 |
```

(4)再填充1列：
```c++
| 0 1 x \ |  dp[1][3]计算步骤向上看
| \ 0 2 \ |  dp[2][3]计算步骤向上看(先填充)
| \ \ 0 \ |
| \ \ \ 0 |
```

(5)再填充最后一列:
```c++
| 0 1 x x |  dp[1][4]计算步骤向上看
| \ 0 2 x |  dp[2][4]计算步骤向上看(然后填充)
| \ \ 0 x |  dp[3][4]计算步骤向上看(先填充)
| \ \ \ 0 |
x都是因为我懒得算了... ... 偷个懒，有兴趣可以自己算
```

```
作者：张小统
链接：https://leetcode.cn/problems/guess-number-higher-or-lower-ii/solutions/83395/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 复杂度

时间复杂度:
> $O(n^3)$

空间复杂度:
> $O(n^2)$

# Code
```C++
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));
        for (int i = 0; i <= n; ++i) dp[i][i] = 0;
        for (int j = 2; j <= n; ++j)
            for (int i = j - 1; i >= 1; --i)
            {
                for (int k = i + 1; k <= j - 1; k++)
                    dp[i][j] = min(k + max(dp[i][k - 1], dp[k + 1][j]), dp[i][j]);
                dp[i][j] = min(dp[i][j], i + dp[i + 1][j]);
                dp[i][j] = min(dp[i][j], j + dp[i][j - 1]);
            }
        return dp[1][n];
    }
};
```
  
