---
Difficulty: "Hard"
tags: ["dp"]
---

> Problem: [514. 自由之路](https://leetcode.cn/problems/freedom-trail/description/)

# 思路

> Dp

- mn 為本次移動的數字
- $mn += dp[pos][j + 1]$ 加上次移動的步數，除了最後一步

# 复杂度

时间复杂度:
> $O(n^2m)$

空间复杂度:
> $O(nm)$

# Code
```C++ []
class Solution {
public:
    int findRotateSteps(string ring, string key) {
        int n = ring.size(), m = key.size();
        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));
        for (int j = m - 1; j >= 0; --j)
        {
            for (int i = n - 1; i >= 0; --i)
            {
                auto ch = key[j];
                int idx = 0;
                for (int idx = 0; idx < n; ++idx)
                {
                    int pos = (i + idx) % n;
                    if (ring[pos] == ch)
                    {
                        int mn = min(idx, n - idx);
                        if (j != m - 1)
                            mn += dp[pos][j + 1];
                        dp[i][j] = min(dp[i][j], mn + 1);
                    }
                }
            }
        }
        return dp[0][0];
    }
};
```
  
