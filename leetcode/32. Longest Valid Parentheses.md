---
title: "32. Longest Valid Parentheses"
tags: ["monotonic stack"]
---

> Problem: [32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/description/)

# Reasoning 
- The main idea is that:
- when meet '(', push the index in stack
- when meet ')', check whether the stack is empty.
- if not empty, that means the stack has either '(' or ')' on the top

> if '(' on the top, it can form a valid parenthese, so pop it
- then check whether it is empty again, 
- to find the distance of valid parentheses

> if ')' on the top, it is invalid since ')' and ')' can't form valid parenthese
- it maintain only 1 ')' in the stack (reader should verify this statement)
- so if it is invalid situation, then pop the previous ')' out, the stack is now empty
- push the new ')' into the stack to record the new invalid situation.

NOTE: push -1 to the stack at the begining to ensure later algorithm push the first invalid ')' into stack

# Complexity
## Time Complexity
> $O(N)$
## Space Complexity
> $O(N)$
where N be the length of string s

# Code
```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        st.push(-1);

        int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(')
                st.push(i);
            else {
                if (st.size()) {
                    st.pop();

                    if (st.size())
                        ans = max(ans, i - st.top());
                    else 
                        st.push(i);
                }
            }
        }

        return ans;
    }
};
```